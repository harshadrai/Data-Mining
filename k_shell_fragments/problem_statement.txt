Given a relational dataset, you need to compute the k-shell fragments.

Input Format

The input dataset can have upto 26 categorical attributes, A, B, ..., Z. Each categorical attribute can have upto 6 different values. The possible values of an attribute X are represented using x1, x2, etc. For example, if attribute B has 3 possible values, then these values are represented using b1, b2, b3. Note that, all possible values of an attribute may not appear on the dataset.

The first line of input will be the number of partitions k. Determine the number of attribtes in each partition by distributing n (the # of attributes) across k partitions in a circular round robin fashion. For example, if a dataset has 10 attributes and k is 3, then the 1st partition will have 4 attributes, whereas the 2nd and 3rd partition will have 3 attributes.

Each following line of input will contain one row of the dataset that will list the values corresponding to the attributes. You can assume that each row will have values for all attributes, i.e., no missing attribute. Also, all attributes will follow the same ordering of attributes. For example, if the first row lists the value corresponding to attribute C first, and then lists the value corresponding to attribute A, all following rows will do the same. Here is a sample input.

2
a1 b2 c1 d1 e1
a1 b2 c1 d2 e1
a1 b2 c1 d1 e2
a2 b1 c1 d1 e2
a2 b1 c1 d1 e3

Here, the number of partitions is 2. The dataset has five attributes, A, B, C, D, E and five rows. The first row has a1 as the value for A, b2 as the value for B, c1 as the value of C, d1 as the value of D and finally e1 as the value of E.

Constraints

NA

Output Format

The output is the fragmented cubes generated by the frag shells algorithm.

The fragmentation/partitioning of attributes needs to be done based on their ordering at input. For example, if the input dataset lists attributes C, A, D, B, F, and k is 2; then the first partition will have {C, A, D}, and the second partition will have {B, F}.

For each partition, you need to generate all non-empty cells for all cuboids. For example for partition {C, A, D}, the cuboids will be {C}, {A}, {D}, {C, A}, {C, D}, {A, D}, {C, A, D}. For each of these cuboids, you need to generate the non-empty cells.

You need to print the cells of cuboids as per the ordering of partitioning, i.e., first printing the cells corresponding to first partition, then printing the cells corresponding to second partition, and so on. The cells of any two partitions should be separetd by an empty line.

A cell is described by a list of values for different attributes and the support. For example, the cell A = a1, B = b2 is described as a1 b2 : 3. Here, the 3 after colon is the support of the cell, i.e., there are 3 rows where A= a1, B = b2. Note that, the values are listed as per the order of attributes at input. For example, A = a1, B = b2 is written as a1 b2 : 3 if attribute A appears before attribute B in the dataset.

The cells corresponding to any partition should be printed one cell per line, as per the following ordering rules. (i) Cells from coarser granularity cuboids needs to appear before the cells from finer granularity cuboids. For example, for a partition {C, A, D}, the non-empty cells corresponding to cuboids {C}, {A}, {D} needs to appear before the non-empty cells corresponding to cuboid {C, A}, {C, D}, {A, D}. Similarly, the non-empty cells corresponding to cuboids {C, A}, {C, D}, {A, D} needs to appear before the non-empty cells corresponding to cuboid {C, A, D}. (ii) For cells from cuboid of same granularity, the ordering of cells is determined based on the ordering of attributes involved in the cuboid. For example, for partition {C, A, D}, {C} < {A} < {D}, and {C, A} < {C, D} < {A, D}. (ii) Finally, for cells within the same cuboid the ordering is determined based on the attribute value combination. For example c1 a1 < c1 a2 < c2 a1 < c2 a2.

Here's the output corresponding to our sample input.

a1 : 3
a2 : 2
b1 : 2
b2 : 3
c1 : 5
a1 b2 : 3
a2 b1 : 2
a1 c1 : 3
a2 c1 : 2
b1 c1 : 2
b2 c1 : 3
a1 b2 c1 : 3
a2 b1 c1 : 2

d1 : 4
d2 : 1
e1 : 2
e2 : 2
e3 : 1
d1 e1 : 1
d1 e2 : 2
d1 e3 : 1
d2 e1 : 1

Sample Input 0

2
a1 b2 c1 d1 e1
a1 b2 c1 d2 e1
a1 b2 c1 d1 e2
a2 b1 c1 d1 e2
a2 b1 c1 d1 e3
Sample Output 0

a1 : 3
a2 : 2
b1 : 2
b2 : 3
c1 : 5
a1 b2 : 3
a2 b1 : 2
a1 c1 : 3
a2 c1 : 2
b1 c1 : 2
b2 c1 : 3
a1 b2 c1 : 3
a2 b1 c1 : 2

d1 : 4
d2 : 1
e1 : 2
e2 : 2
e3 : 1
d1 e1 : 1
d1 e2 : 2
d1 e3 : 1
d2 e1 : 1